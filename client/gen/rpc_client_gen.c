#include "rpc_client_gen.h"
#include "rpc_codec.h"
#include "rpc_async.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>

// AUTO-GENERATED BY tools/gen_rpc_client.py
// DO NOT MODIFY MANUALLY

char* ping(void) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("ping", params, id);

    char* ret_val = NULL;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsString(result)) {
                ret_val = strdup(result->valuestring);
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC ping failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}

int64_t echo_i64(int64_t x) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();
    {
        char buf[32];
        snprintf(buf, sizeof(buf), "%" PRId64, x);
        cJSON_AddStringToObject(params, "x", buf);
    }

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("echo_i64", params, id);

    int64_t ret_val = 0;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsString(result)) {
                ret_val = strtoll(result->valuestring, NULL, 10);
            } else if (result && cJSON_IsNumber(result)) {
                ret_val = (int64_t)result->valuedouble;
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC echo_i64 failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}

int32_t add_i32(int32_t a, int32_t b) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();
    cJSON_AddNumberToObject(params, "a", (double)a);
    cJSON_AddNumberToObject(params, "b", (double)b);

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("add_i32", params, id);

    int32_t ret_val = 0;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsNumber(result)) {
                ret_val = (int32_t)result->valuedouble;
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC add_i32 failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}

double mul_double(double a, double b) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();
    cJSON_AddNumberToObject(params, "a", (double)a);
    cJSON_AddNumberToObject(params, "b", (double)b);

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("mul_double", params, id);

    double ret_val = 0;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsNumber(result)) {
                ret_val = (double)result->valuedouble;
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC mul_double failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}

bool is_even(int32_t n) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();
    cJSON_AddNumberToObject(params, "n", (double)n);

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("is_even", params, id);

    bool ret_val = false;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsBool(result)) {
                ret_val = cJSON_IsTrue(result);
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC is_even failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}

int32_t strlen_s(const char* s) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();
    cJSON_AddStringToObject(params, "s", s);

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("strlen_s", params, id);

    int32_t ret_val = 0;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsNumber(result)) {
                ret_val = (int32_t)result->valuedouble;
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC strlen_s failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}

char* mix3(int32_t a, double b, bool ok) {
    // 1. 打包参数
    cJSON* params = cJSON_CreateObject();
    cJSON_AddNumberToObject(params, "a", (double)a);
    cJSON_AddNumberToObject(params, "b", (double)b);
    cJSON_AddBoolToObject(params, "ok", ok);

    // 2. 协议编码
    uint32_t id = rpc_async_next_id();
    char* req_json = rpc_codec_encode_request("mix3", params, id);

    char* ret_val = NULL;
    char* resp_json = NULL;
    size_t resp_len = 0;
    rpc_error_code status;

    // 3. 传输层调用 (阻塞等待)
    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {
        // 4. 协议解码
        uint32_t resp_id;
        cJSON *result = NULL, *error = NULL;
        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {
            // 5. 结果拆包
            if (result && cJSON_IsString(result)) {
                ret_val = strdup(result->valuestring);
            }
            if (result) cJSON_Delete(result);
            if (error) cJSON_Delete(error);
        }
        if (resp_json) free(resp_json);
    } else {
        fprintf(stderr, "RPC mix3 failed with status %d\n", status);
    }
    
    if (req_json) free(req_json);
    return ret_val;
}
