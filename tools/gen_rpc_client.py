#!/usr/bin/env python3
import json
import os
import sys

def get_repo_root():
    return os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))

IDL_PATH = os.path.join(get_repo_root(), "rpc_idl.json")
GEN_DIR = os.path.join(get_repo_root(), "client", "gen")
HEADER_PATH = os.path.join(GEN_DIR, "rpc_client_gen.h")
SOURCE_PATH = os.path.join(GEN_DIR, "rpc_client_gen.c")

def load_idl():
    with open(IDL_PATH, 'r') as f:
        return json.load(f)

def get_c_type(idl, type_name):
    return idl['types'][type_name]['c_type']

def generate_header(idl):
    lines = [
        "#pragma once",
        "#include <stdint.h>",
        "#include <stdbool.h>",
        "",
        "// AUTO-GENERATED BY tools/gen_rpc_client.py",
        "// DO NOT MODIFY MANUALLY",
        ""
    ]
    
    for func in idl['functions']:
        method = func['method']
        description = func.get('description', '')
        if description:
            lines.append(f"// {description}")
            
        ret_type = get_c_type(idl, func['result']['type'])
        if func['result']['type'] == 'string':
            ret_type = "char*" # For generated code, we return a malloced string for results
            
        params = []
        for p_name, p_info in func['params']['properties'].items():
            p_type = get_c_type(idl, p_info['type'])
            params.append(f"{p_type} {p_name}")
        
        param_str = ", ".join(params) if params else "void"
        lines.append(f"{ret_type} {method}({param_str});")
        
    return "\n".join(lines)

def generate_source(idl):
    lines = [
        '#include "rpc_client_gen.h"',
        '#include "rpc_codec.h"',
        '#include "rpc_async.h"',
        '#include <stdlib.h>',
        '#include <stdio.h>',
        '#include <string.h>',
        '#include <inttypes.h>',
        "",
        "// AUTO-GENERATED BY tools/gen_rpc_client.py",
        "// DO NOT MODIFY MANUALLY",
        ""
    ]
    
    for func in idl['functions']:
        method = func['method']
        idl_ret_type = func['result']['type']
        ret_type = get_c_type(idl, idl_ret_type)
        if idl_ret_type == 'string':
            ret_type = "char*"
            
        params_list = []
        for p_name, p_info in func['params']['properties'].items():
            p_type = get_c_type(idl, p_info['type'])
            params_list.append(f"{p_type} {p_name}")
        
        param_str = ", ".join(params_list) if params_list else "void"
        
        lines.append(f"{ret_type} {method}({param_str}) {{")
        lines.append("    // 1. 打包参数")
        lines.append("    cJSON* params = cJSON_CreateObject();")
        
        for p_name, p_info in func['params']['properties'].items():
            ptype = p_info['type']
            if ptype == 'i32' or ptype == 'double':
                lines.append(f'    cJSON_AddNumberToObject(params, "{p_name}", (double){p_name});')
            elif ptype == 'i64':
                lines.append(f'    {{')
                lines.append(f'        char buf[32];')
                lines.append(f'        snprintf(buf, sizeof(buf), "%" PRId64, {p_name});')
                lines.append(f'        cJSON_AddStringToObject(params, "{p_name}", buf);')
                lines.append(f'    }}')
            elif ptype == 'bool':
                lines.append(f'    cJSON_AddBoolToObject(params, "{p_name}", {p_name});')
            elif ptype == 'string':
                lines.append(f'    cJSON_AddStringToObject(params, "{p_name}", {p_name});')
        
        lines.append("")
        lines.append("    // 2. 协议编码")
        lines.append("    uint32_t id = rpc_async_next_id();")
        lines.append(f'    char* req_json = rpc_codec_encode_request("{method}", params, id);')
        lines.append("")
        
        if idl_ret_type == 'string':
            lines.append(f"    {ret_type} ret_val = NULL;")
        elif idl_ret_type == 'bool':
             lines.append(f"    {ret_type} ret_val = false;")
        else:
            lines.append(f"    {ret_type} ret_val = 0;")
            
        lines.append("    char* resp_json = NULL;")
        lines.append("    size_t resp_len = 0;")
        lines.append("    rpc_error_code status;")
        lines.append("")
        lines.append("    // 3. 传输层调用 (阻塞等待)")
        lines.append("    if (rpc_call_async_blocking(req_json, id, &resp_json, &resp_len, &status) == 0) {")
        lines.append("        // 4. 协议解码")
        lines.append("        uint32_t resp_id;")
        lines.append("        cJSON *result = NULL, *error = NULL;")
        lines.append("        if (rpc_codec_decode_response(resp_json, &resp_id, &result, &error) == 0) {")
        lines.append("            // 5. 结果拆包")
        
        # Result handling
        if idl_ret_type == 'i32' or idl_ret_type == 'double':
            lines.append(f"            if (result && cJSON_IsNumber(result)) {{")
            lines.append(f"                ret_val = ({ret_type})result->valuedouble;")
            lines.append(f"            }}")
        elif idl_ret_type == 'i64':
            lines.append(f"            if (result && cJSON_IsString(result)) {{")
            lines.append(f'                ret_val = strtoll(result->valuestring, NULL, 10);')
            lines.append(f"            }} else if (result && cJSON_IsNumber(result)) {{")
            lines.append(f"                ret_val = (int64_t)result->valuedouble;")
            lines.append(f"            }}")
        elif idl_ret_type == 'bool':
            lines.append(f"            if (result && cJSON_IsBool(result)) {{")
            lines.append(f"                ret_val = cJSON_IsTrue(result);")
            lines.append(f"            }}")
        elif idl_ret_type == 'string':
            lines.append(f"            if (result && cJSON_IsString(result)) {{")
            lines.append(f"                ret_val = strdup(result->valuestring);")
            lines.append(f"            }}")
            
        lines.append("            if (result) cJSON_Delete(result);")
        lines.append("            if (error) cJSON_Delete(error);")
        lines.append("        }")
        lines.append("        if (resp_json) free(resp_json);")
        lines.append("    } else {")
        lines.append(f'        fprintf(stderr, "RPC {method} failed with status %d\\n", status);')
        lines.append("    }")
        lines.append("    ")
        lines.append("    if (req_json) free(req_json);")
        lines.append("    return ret_val;")
        lines.append("}")
        lines.append("")
        
    return "\n".join(lines)

def main():
    idl = load_idl()
    
    if not os.path.exists(GEN_DIR):
        os.makedirs(GEN_DIR)
        print(f"Created directory {GEN_DIR}")

    header_content = generate_header(idl)
    with open(HEADER_PATH, 'w') as f:
        f.write(header_content)
    print(f"Generated {HEADER_PATH}")
    
    source_content = generate_source(idl)
    with open(SOURCE_PATH, 'w') as f:
        f.write(source_content)
    print(f"Generated {SOURCE_PATH}")

if __name__ == "__main__":
    main()
