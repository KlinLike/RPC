import json
import os
from typing import Any, Dict, List, Tuple


def _repo_root() -> str:
    return os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))


IDL_PATH = os.path.join(_repo_root(), "rpc_idl.json")
OUT_PATH = os.path.join(_repo_root(), "gen", "rpc_client_stub.c")


def _load_idl(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def _c_type_from_idl_type(idl: Dict[str, Any], type_name: str) -> str:
    types = idl.get("types", {})
    t = types.get(type_name)
    if not isinstance(t, dict) or "c_type" not in t:
        raise ValueError(f"Unknown type: {type_name}")
    return str(t["c_type"])


def _extract_params(fn: Dict[str, Any]) -> List[Tuple[str, str]]:
    params = fn.get("params")
    if not isinstance(params, dict):
        raise ValueError(f"Invalid params schema for method {fn.get('method')}")

    if params.get("type") != "object":
        raise ValueError(f"Only params.type==object is supported (method {fn.get('method')})")

    props = params.get("properties")
    if not isinstance(props, dict):
        raise ValueError(f"params.properties must be an object (method {fn.get('method')})")

    required = params.get("required")
    if isinstance(required, list) and all(isinstance(x, str) for x in required):
        ordered_names = list(required)
    else:
        ordered_names = list(props.keys())

    out: List[Tuple[str, str]] = []
    for name in ordered_names:
        schema = props.get(name)
        if not isinstance(schema, dict) or "type" not in schema:
            raise ValueError(f"Invalid param schema for {fn.get('method')}.{name}")
        out.append((name, str(schema["type"])))

    return out


def _emit_preamble(lines: List[str]) -> None:
    lines.extend(
        [
            "/*",
            " * AUTO-GENERATED FILE. DO NOT EDIT.",
            " * Generated by: tools/gen_rpc_client_stub.py",
            " */",
            "",
            '#include <stdio.h>',
            '#include <stdlib.h>',
            '#include <string.h>',
            '#include <inttypes.h>',
            '#include <stdint.h>',
            '#include <stdbool.h>',
            "",
            '#include "cJSON.h"',
            '#include "rpc_client.h"',
            '#include "rpc_api.h"',
            "",
            "static uint32_t g_rpc_request_id = 1;",
            "",
            "static char* rpc_strdup(const char* s)",
            "{",
            "    if (s == NULL) {",
            "        return NULL;",
            "    }",
            "    size_t n = strlen(s);",
            "    char* out = (char*)malloc(n + 1);",
            "    if (out == NULL) {",
            "        return NULL;",
            "    }",
            "    memcpy(out, s, n + 1);",
            "    return out;",
            "}",
            "",
            "// 构造 JSON-RPC 2.0 请求字符串：{jsonrpc, method, params, id}。",
            "// 返回堆上分配的字符串，调用者需要 free()。",
            "static char* rpc_build_request(const char* method, cJSON* params)",
            "{",
            "    cJSON* root = cJSON_CreateObject();",
            "    if (root == NULL) {",
            "        return NULL;",
            "    }",
            "    if (cJSON_AddStringToObject(root, \"jsonrpc\", \"2.0\") == NULL) {",
            "        cJSON_Delete(root);",
            "        return NULL;",
            "    }",
            "    if (cJSON_AddStringToObject(root, \"method\", method) == NULL) {",
            "        cJSON_Delete(root);",
            "        return NULL;",
            "    }",
            "    if (params != NULL) {",
            "        cJSON_AddItemToObject(root, \"params\", params);",
            "    }",
            "    cJSON_AddNumberToObject(root, \"id\", (double)g_rpc_request_id++);",
            "",
            "    char* out = cJSON_PrintUnformatted(root);",
            "    cJSON_Delete(root);",
            "    return out;",
            "}",
            "",
            "// 解析 JSON 字符串为 cJSON 对象。",
            "// 返回 cJSON*，调用者需要使用 cJSON_Delete() 释放。",
            "static cJSON* rpc_parse_response(const char* json)",
            "{",
            "    if (json == NULL) {",
            "        return NULL;",
            "    }",
            "    return cJSON_Parse(json);",
            "}",
            "",
        ]
    )


def _emit_param_add(lines: List[str], pname: str, idl_type: str) -> None:
    if idl_type in ("i32", "double"):
        # cJSON stores numbers as double.
        lines.append(f"    cJSON_AddNumberToObject(params, \"{pname}\", (double){pname});")
    elif idl_type == "i64":
        lines.extend(
            [
                "    {",
                f"        char buf_{pname}[32];",
                f"        snprintf(buf_{pname}, sizeof(buf_{pname}), \"%\" PRId64, (int64_t){pname});",
                f"        cJSON_AddStringToObject(params, \"{pname}\", buf_{pname});",
                "    }",
            ]
        )
    elif idl_type == "bool":
        lines.append(f"    cJSON_AddBoolToObject(params, \"{pname}\", {pname});")
    elif idl_type == "string":
        lines.append(f"    cJSON_AddStringToObject(params, \"{pname}\", {pname});")
    else:
        raise ValueError(f"Unsupported param type for now: {idl_type}")


def _emit_result_parse(lines: List[str], ret_c: str, idl_ret_type: str) -> None:
    # Default return on error
    if ret_c == "double":
        default_ret = "0.0"
    elif ret_c == "char*":
        default_ret = "NULL"
    else:
        default_ret = "0"

    lines.extend(
        [
            "    if (resp_json == NULL) {",
            f"        return {default_ret};",
            "    }",
            "",
            "    cJSON* root = rpc_parse_response(resp_json);",
            "    free(resp_json);",
            "    if (root == NULL) {",
            f"        return {default_ret};",
            "    }",
            "",
            "    cJSON* err = cJSON_GetObjectItemCaseSensitive(root, \"error\");",
            "    if (err != NULL) {",
            "        cJSON_Delete(root);",
            f"        return {default_ret};",
            "    }",
            "",
            "    cJSON* result = cJSON_GetObjectItemCaseSensitive(root, \"result\");",
            "    if (result == NULL) {",
            "        cJSON_Delete(root);",
            f"        return {default_ret};",
            "    }",
        ]
    )

    if idl_ret_type in ("i32", "i64"):
        if idl_ret_type == "i64":
            lines.extend(
                [
                    "    if (cJSON_IsString(result) && result->valuestring != NULL) {",
                    "        char* endptr = NULL;",
                    "        long long tmp = strtoll(result->valuestring, &endptr, 10);",
                    "        if (endptr == result->valuestring || *endptr != '\\0') {",
                    "            cJSON_Delete(root);",
                    f"            return {default_ret};",
                    "        }",
                    f"        {ret_c} v = ({ret_c})tmp;",
                    "        cJSON_Delete(root);",
                    "        return v;",
                    "    }",
                    "    if (cJSON_IsNumber(result)) {",
                    f"        {ret_c} v = ({ret_c})result->valuedouble;",
                    "        cJSON_Delete(root);",
                    "        return v;",
                    "    }",
                    "    cJSON_Delete(root);",
                    f"    return {default_ret};",
                ]
            )
        else:
            lines.extend(
                [
                    "    if (!cJSON_IsNumber(result)) {",
                    "        cJSON_Delete(root);",
                    f"        return {default_ret};",
                    "    }",
                    f"    {ret_c} v = ({ret_c})result->valuedouble;",
                    "    cJSON_Delete(root);",
                    "    return v;",
                ]
            )
    elif idl_ret_type == "double":
        lines.extend(
            [
                "    if (!cJSON_IsNumber(result)) {",
                "        cJSON_Delete(root);",
                f"        return {default_ret};",
                "    }",
                f"    {ret_c} v = ({ret_c})result->valuedouble;",
                "    cJSON_Delete(root);",
                "    return v;",
            ]
        )
    elif idl_ret_type == "bool":
        lines.extend(
            [
                "    if (!cJSON_IsBool(result)) {",
                "        cJSON_Delete(root);",
                f"        return {default_ret};",
                "    }",
                f"    {ret_c} v = cJSON_IsTrue(result);",
                "    cJSON_Delete(root);",
                "    return v;",
            ]
        )
    elif idl_ret_type == "string":
        lines.extend(
            [
                "    if (!cJSON_IsString(result) || result->valuestring == NULL) {",
                "        cJSON_Delete(root);",
                f"        return {default_ret};",
                "    }",
                "    char* v = rpc_strdup(result->valuestring);",
                "    cJSON_Delete(root);",
                "    return v;",
            ]
        )
    else:
        raise ValueError(f"Unsupported return type for now: {idl_ret_type}")


def generate_rpc_client_stub() -> None:
    idl = _load_idl(IDL_PATH)

    functions = idl.get("functions")
    if not isinstance(functions, list):
        raise ValueError("idl.functions must be an array")

    lines: List[str] = []
    _emit_preamble(lines)

    for fn in functions:
        if not isinstance(fn, dict):
            raise ValueError("Each element of idl.functions must be an object")

        method = fn.get("method")
        if not isinstance(method, str) or not method:
            raise ValueError("functions[].method must be a non-empty string")

        desc = fn.get("description")
        if isinstance(desc, str) and desc.strip():
            lines.append(f"// {desc.strip()}")

        result = fn.get("result")
        if not isinstance(result, dict) or "type" not in result:
            raise ValueError(f"functions[].result.type is required (method {method})")

        idl_ret_type = str(result["type"])
        if idl_ret_type == "string":
            ret_c = "char*"
        else:
            ret_c = _c_type_from_idl_type(idl, idl_ret_type)

        params = _extract_params(fn)
        sig_parts: List[str] = []
        for (pname, ptype) in params:
            sig_parts.append(f"{_c_type_from_idl_type(idl, ptype)} {pname}")

        lines.append(f"{ret_c} {method}({', '.join(sig_parts)})")
        lines.append("{")
        lines.append("    cJSON* params = cJSON_CreateObject();")
        lines.append("    if (params == NULL) {")
        if ret_c == "double":
            lines.append("        return 0.0;")
        elif ret_c == "char*":
            lines.append("        return NULL;")
        else:
            lines.append("        return 0;")
        lines.append("    }")

        for (pname, ptype) in params:
            _emit_param_add(lines, pname, ptype)

        lines.append(f"    char* req = rpc_build_request(\"{method}\", params);")
        lines.append("    if (req == NULL) {")
        lines.append("        cJSON_Delete(params);")
        if ret_c == "double":
            lines.append("        return 0.0;")
        elif ret_c == "char*":
            lines.append("        return NULL;")
        else:
            lines.append("        return 0;")
        lines.append("    }")

        lines.append("    char* resp_json = rpc_client_call(req);")
        lines.append("    free(req);")

        _emit_result_parse(lines, ret_c, idl_ret_type)
        lines.append("}")
        lines.append("")

    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)
    with open(OUT_PATH, "w", encoding="utf-8") as f:
        f.write("\n".join(lines).rstrip())
        f.write("\n")


def main() -> int:
    generate_rpc_client_stub()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
