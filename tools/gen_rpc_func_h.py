import json
import os
from typing import Any, Dict, List, Tuple


def _repo_root() -> str:
    # tools/gen_rpc_func_h.py -> repo root
    return os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))


IDL_PATH = os.path.join(_repo_root(), "rpc_idl.json")
OUT_PATH = os.path.join(_repo_root(), "gen", "rpc_api.h")


def _load_idl(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def _c_type_from_idl_type(idl: Dict[str, Any], type_name: str) -> str:
    types = idl.get("types", {})
    t = types.get(type_name)
    if not isinstance(t, dict) or "c_type" not in t:
        raise ValueError(f"Unknown type: {type_name}")
    return str(t["c_type"])


def _extract_params(fn: Dict[str, Any]) -> List[Tuple[str, str]]:
    params = fn.get("params")
    if not isinstance(params, dict):
        raise ValueError(f"Invalid params schema for method {fn.get('method')}")

    if params.get("type") != "object":
        raise ValueError(f"Only params.type==object is supported (method {fn.get('method')})")

    props = params.get("properties")
    if not isinstance(props, dict):
        raise ValueError(f"params.properties must be an object (method {fn.get('method')})")

    required = params.get("required")
    if isinstance(required, list) and all(isinstance(x, str) for x in required):
        ordered_names = list(required)
    else:
        ordered_names = list(props.keys())

    out: List[Tuple[str, str]] = []
    for name in ordered_names:
        schema = props.get(name)
        if not isinstance(schema, dict) or "type" not in schema:
            raise ValueError(f"Invalid param schema for {fn.get('method')}.{name}")
        out.append((name, str(schema["type"])))

    return out


def _emit_header_preamble(lines: List[str]) -> None:
    lines.append("/*")
    lines.append(" * AUTO-GENERATED FILE. DO NOT EDIT.")
    lines.append(" * Generated by: tools/gen_rpc_func_h.py")
    lines.append(" */")
    lines.append("")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("#include <stdbool.h>")
    lines.append("")


def generate_rpc_func_h() -> None:
    idl = _load_idl(IDL_PATH)

    functions = idl.get("functions")
    if not isinstance(functions, list):
        raise ValueError("idl.functions must be an array")

    lines: List[str] = []
    _emit_header_preamble(lines)

    for fn in functions:
        if not isinstance(fn, dict):
            raise ValueError("Each element of idl.functions must be an object")

        method = fn.get("method")
        if not isinstance(method, str) or not method:
            raise ValueError("functions[].method must be a non-empty string")

        desc = fn.get("description")
        if isinstance(desc, str) and desc.strip():
            lines.append(f"// {desc.strip()}")

        result = fn.get("result")
        if not isinstance(result, dict) or "type" not in result:
            raise ValueError(f"functions[].result.type is required (method {method})")

        ret_c = _c_type_from_idl_type(idl, str(result["type"]))
        params = _extract_params(fn)
        param_parts: List[str] = []
        for (pname, ptype) in params:
            p_c = _c_type_from_idl_type(idl, ptype)
            param_parts.append(f"{p_c} {pname}")

        lines.append(f"{ret_c} {method}({', '.join(param_parts)});")
        lines.append("")

    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)
    with open(OUT_PATH, "w", encoding="utf-8") as f:
        f.write("\n".join(lines).rstrip())
        f.write("\n")


def main() -> int:
    generate_rpc_func_h()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
