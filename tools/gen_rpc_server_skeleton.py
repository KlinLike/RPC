#!/usr/bin/env python3
import json
from pathlib import Path
from typing import Dict, List

ROOT = Path(__file__).resolve().parent.parent
IN_PATH = ROOT / "rpc_idl.json"
OUT_H = ROOT / "server" / "gen" / "rpc_server_skeleton.h"
OUT_C = ROOT / "server" / "gen" / "rpc_server_skeleton.c"
OUT_IMPL_H = ROOT / "server" / "gen" / "rpc_server_impl.h"


def load_idl(path: Path) -> Dict:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def c_type(idl_type: str) -> str:
    if idl_type == "i32":
        return "int32_t"
    if idl_type == "i64":
        return "int64_t"
    if idl_type == "double":
        return "double"
    if idl_type == "bool":
        return "bool"
    if idl_type == "string":
        return "const char*"
    raise ValueError(f"Unsupported type: {idl_type}")


def emit_header(idl: Dict) -> str:
    lines: List[str] = [
        "/*",
        " * AUTO-GENERATED FILE. DO NOT EDIT.",
        " * Generated by: tools/gen_rpc_server_skeleton.py",
        " * 内容：",
        " *  1) 每个 method 的参数解析辅助函数声明；",
        " *  2) dispatch 声明（rpc_server_dispatch）。",
        " */",
        "",
        "#pragma once",
        "",
        "#include <stdint.h>",
        "#include <stdbool.h>",
        "#include <inttypes.h>",
        "#include \"cJSON.h\"",
        "",
        "// 每个 *_impl 由业务代码实现；解析辅助函数由生成器提供。",
        "",
    ]

    for fn in idl["functions"]:
        method = fn["method"]
        desc = fn.get("description", "")
        params = fn["params"]["properties"]

        parser_params = [f"{c_type(spec['type'])}* out_{name}" for name, spec in params.items()]
        parser_sig = ", ".join(parser_params)
        sig_tail = f", {parser_sig}" if parser_sig else ""
        lines.append(f"// 解析 params 为 {method} 所需参数，成功返回 true。字符串参数输出为指向 cJSON 内部缓冲区的指针，需保证 cJSON 生命周期。")
        lines.append(f"bool rpc_parse_params_{method}(cJSON* params{sig_tail});")
        lines.append("")

    lines.append("// 由生成器提供的 dispatch：解析请求 JSON，调用对应 *_impl，并返回响应 JSON 字符串（需 free）。")
    lines.append("char* rpc_server_dispatch(const char* req_json);")
    lines.append("")

    return "\n".join(lines)


def emit_source(idl: Dict) -> str:
    lines: List[str] = [
        "/*",
        " * AUTO-GENERATED FILE. DO NOT EDIT.",
        " * Generated by: tools/gen_rpc_server_skeleton.py",
        " */",
        "",
        "#include <string.h>",
        "#include <stdio.h>",
        "#include <stdlib.h>",
        "#include \"rpc_server_skeleton.h\"",
        "#include \"rpc_server_helpers.h\"",
        "#include \"rpc_server_impl.h\"",
        "",
    ]

    for fn in idl["functions"]:
        method = fn["method"]
        params = fn["params"]["properties"]
        param_sig_parts = [f"{c_type(spec['type'])}* out_{name}" for name, spec in params.items()]
        sig_tail = ", " + ", ".join(param_sig_parts) if param_sig_parts else ""
        parser_body: List[str] = [
            f"bool rpc_parse_params_{method}(cJSON* params{sig_tail})",
            "{",
            "    if (params == NULL) {",
            "        return false;",
            "    }",
        ]

        for name, spec in params.items():
            idl_type = spec["type"]
            parser_body.append(f"    cJSON* item_{name} = cJSON_GetObjectItemCaseSensitive(params, \"{name}\");")
            if idl_type == "i32":
                parser_body.extend(
                    [
                        f"    if (!cJSON_IsNumber(item_{name})) {{",
                        "        return false;",
                        "    }",
                        f"    *out_{name} = (int32_t)item_{name}->valuedouble;",
                    ]
                )
            elif idl_type == "double":
                parser_body.extend(
                    [
                        f"    if (!cJSON_IsNumber(item_{name})) {{",
                        "        return false;",
                        "    }",
                        f"    *out_{name} = (double)item_{name}->valuedouble;",
                    ]
                )
            elif idl_type == "bool":
                parser_body.extend(
                    [
                        f"    if (!cJSON_IsBool(item_{name})) {{",
                        "        return false;",
                        "    }",
                        f"    *out_{name} = (item_{name}->type & cJSON_True) != 0;",
                    ]
                )
            elif idl_type == "string":
                parser_body.extend(
                    [
                        f"    if (!cJSON_IsString(item_{name}) || item_{name}->valuestring == NULL) {{",
                        "        return false;",
                        "    }",
                        f"    *out_{name} = item_{name}->valuestring;",
                    ]
                )
            elif idl_type == "i64":
                parser_body.extend(
                    [
                        f"    if (!rpc_parse_i64_value(item_{name}, out_{name})) {{",
                        "        return false;",
                        "    }",
                    ]
                )
            else:
                raise ValueError(f"Unsupported type: {idl_type}")

        parser_body.append("    return true;")
        parser_body.append("}")
        parser_body.append("")
        lines.extend(parser_body)

    # dispatch
    lines.extend(
        [
            "char* rpc_server_dispatch(const char* req_json)",
            "{",
            "    if (req_json == NULL) {",
            "        return rpc_build_error_response(0, -32600, \"Invalid Request\");",
            "    }",
            "",
            "    cJSON* root = cJSON_Parse(req_json);",
            "    if (root == NULL) {",
            "        return rpc_build_error_response(0, -32700, \"Parse error\");",
            "    }",
            "",
            "    cJSON* id_item = cJSON_GetObjectItemCaseSensitive(root, \"id\");",
            "    uint32_t id = 0;",
            "    if (cJSON_IsNumber(id_item)) {",
            "        if (id_item->valuedouble < 0 || id_item->valuedouble > (double)UINT32_MAX) {",
            "            cJSON_Delete(root);",
            "            return rpc_build_error_response(0, -32600, \"Invalid Request\");",
            "        }",
            "        id = (uint32_t)id_item->valuedouble;",
            "    }",
            "",
            "    cJSON* method = cJSON_GetObjectItemCaseSensitive(root, \"method\");",
            "    if (!cJSON_IsString(method) || method->valuestring == NULL) {",
            "        cJSON_Delete(root);",
            "        return rpc_build_error_response(id, -32600, \"Invalid Request\");",
            "    }",
            "",
            "    cJSON* params = cJSON_GetObjectItemCaseSensitive(root, \"params\");",
            "    if (params == NULL) {",
            "        params = cJSON_CreateObject();",
            "        if (params == NULL) {",
            "            cJSON_Delete(root);",
            "            return rpc_build_error_response(id, -32603, \"Internal error\");",
            "        }",
            "    } else {",
            "        params = cJSON_Duplicate(params, 1);",
            "        if (params == NULL) {",
            "            cJSON_Delete(root);",
            "            return rpc_build_error_response(id, -32603, \"Internal error\");",
            "        }",
            "    }",
            "",
            "    const char* m = method->valuestring;",
            "    char* resp_json = NULL;",
        ]
    )

    for idx, fn in enumerate(idl["functions"]):
        method = fn["method"]
        params = fn["params"]["properties"]
        result_type = fn["result"]["type"]

        prefix = "    if" if idx == 0 else "    else if"
        lines.append(f"{prefix} (strcmp(m, \"{method}\") == 0) {{")

        # declare vars
        for name, spec in params.items():
            lines.append(f"        {c_type(spec['type'])} {name} = 0;")
        if result_type == "string":
            ret_decl = "        char* r = NULL;"
        elif result_type == "i64":
            ret_decl = "        int64_t r = 0;"
        else:
            ret_decl = f"        {c_type(result_type)} r = 0;"
        lines.append(ret_decl)

        # parse params
        if params:
            args = ", ".join([f"&{name}" for name in params.keys()])
            lines.append(f"        if (!rpc_parse_params_{method}(params, {args})) {{")
            lines.append("            cJSON_Delete(params);")
            lines.append("            cJSON_Delete(root);")
            lines.append("            return rpc_build_error_response(id, -32602, \"Invalid params\");")
            lines.append("        }")

        # call impl
        call_args = ", ".join(params.keys())
        lines.append(f"        r = {method}_impl({call_args});")

        # build result
        if result_type in ("i32", "double"):
            lines.append("        cJSON* result = cJSON_CreateNumber((double)r);")
        elif result_type == "bool":
            lines.append("        cJSON* result = cJSON_CreateBool(r);")
        elif result_type == "string":
            lines.append("        if (r == NULL) {")
            lines.append("            cJSON_Delete(params);")
            lines.append("            cJSON_Delete(root);")
            lines.append("            return rpc_build_error_response(id, -32603, \"Internal error\");")
            lines.append("        }")
            lines.append("        cJSON* result = cJSON_CreateString(r);")
            lines.append("        free(r);")
        elif result_type == "i64":
            lines.append("        char buf[32];")
            lines.append("        snprintf(buf, sizeof(buf), \"%\" PRId64, r);")
            lines.append("        cJSON* result = cJSON_CreateString(buf);")
        else:
            raise ValueError(f"Unsupported result type: {result_type}")

        lines.append("        resp_json = rpc_build_result_response(id, result);")
        lines.append("    }")

    lines.extend(
        [
            "    else {",
            "        resp_json = rpc_build_error_response(id, -32601, \"Method not found\");",
            "    }",
            "",
            "    cJSON_Delete(params);",
            "    cJSON_Delete(root);",
            "    return resp_json;",
            "}",
        ]
    )

    return "\n".join(lines)


def main() -> None:
    idl = load_idl(IN_PATH)
    OUT_H.parent.mkdir(parents=True, exist_ok=True)
    OUT_C.parent.mkdir(parents=True, exist_ok=True)
    OUT_IMPL_H.parent.mkdir(parents=True, exist_ok=True)
    OUT_H.write_text(emit_header(idl) + "\n", encoding="utf-8")
    OUT_C.write_text(emit_source(idl) + "\n", encoding="utf-8")
    # impl-only header
    impl_lines: List[str] = [
        "/*",
        " * AUTO-GENERATED FILE. DO NOT EDIT.",
        " * Generated by: tools/gen_rpc_server_skeleton.py",
        " * 内容：业务实现函数 (*_impl) 的声明，供手写实现引用。",
        " */",
        "",
        "#pragma once",
        "",
        "#include <stdint.h>",
        "#include <stdbool.h>",
    ]
    for fn in idl["functions"]:
        method = fn["method"]
        desc = fn.get("description", "")
        params = fn["params"]["properties"]
        result_type = fn["result"]["type"]

        ret_c = "char*" if result_type == "string" else c_type(result_type)
        param_parts = []
        for name, spec in params.items():
            param_parts.append(f"{c_type(spec['type'])} {name}")
        param_sig = ", ".join(param_parts) if param_parts else "void"
        impl_lines.append(f"// {desc}")
        impl_lines.append(f"{ret_c} {method}_impl({param_sig});")
        impl_lines.append("")

    OUT_IMPL_H.write_text("\n".join(impl_lines) + "\n", encoding="utf-8")

if __name__ == "__main__":
    main()
